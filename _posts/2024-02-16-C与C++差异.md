---
categories: C++
---

# 命名空间

即可由程序员自定义的作用域，域中的定义，在各作用域之间互不干扰。

作用是解决命名冲突

匿名命名空间不用给作用域起名

# const

宏定义是在预处理时做字符串的直接替换，不做类型检查。

const赋予只读属性，有具体的类型，在编译时会做类型检查

# 指针xx与xx指针

1. 常量
   - 指针常量(pointer to const)：
     - int const * xxx
       const int * xxx
     - 无法修改该指针指向的值，但能修改指向
   - 常量指针
     - int * const 
     - 可以修改指向的值，不能修改指向

2. 数组
   - 数组指针
     - ```c++
       int arr[5] = {1,2,3,4,5};
       //arr代表数组首元素地址
       //&arr代表数组的首地址，虽然与数组首元素地址相同，但实际上单位为整个数组，即&arr+1是整个数组后面一位的地址
       int (*p)[5] = &arr;//数组指针
       //(*p)[]可取出数组的元素
       ```
     
   - 指针数组

     - 存储指针的数组

3. 函数

   - 函数指针

     - ```c++
       void func(){}
       int main(){
       void (*func_ptr)() = &func;
       func_ptr();//即通过函数指针调用函数。}		
       ```
   - 指针函数
     - 返回值为指针的函数。可以作用于指向全局变量（不然指向局部变量，函数结束则发生未定义行为）

# new/delete 与malloc/free

1. new/delete是操作符，而malloc/free是库函数。

2. new返回值为对应类型的指针，malloc返回值为void*

3. new可以直接初始化，malloc申请的空间有脏数据。

4. malloc参数为字节数，new则不需要传递大小。

# 引用（最重点）

## 概念

引用是一个**已定义变量**的**别名**

语法：

``` c++
int num = 2;
int & ref = num;
```

注意：

1. &在这里不是取地址符号，而是引用符号（有个空格）
2. 引用类型需与与其绑定的变量的类型相同（学习继承后则有变动）
3. **声明引用的同时必须初始化，否则报错**
4. 引用一经绑定，无法更改绑定

## 本质

C++的引用实际上是一种**被限制的指针**

通常的说法中，引用不占据内存，只是一个变量的别名，但从原理理解，引用底层也是由指针实现的。所以也占据一个指针的大小。



