# 访问修饰符

<span style=color:red;background:yellow>**public:**</span> 公有的访问权限，在类外可以通过对象直接访问公有成员

<span style=color:red;background:yellow>**protected:**</span> 保护的访问权限，在本类中和派生类中可以访问，在类外不能通过对象直接访问（后面学）

<span style=color:red;background:yellow>**private:**</span> 私有的访问权限，在本类之外不能访问，比较敏感的数据设为private，类定义中可以访问。

class默认为private，而在c++中对struct做了扩展，变成了默认为public的class

# 成员函数的定义

- **形式**

    可在内部声明，外部定义

    ```c++
  class Computer {
  public:
  	//内部声明
  	void setBrand(const char * brand);
  private:
      char _brand[20];
  };
  
  //类外定义
  void Computer::setBrand(const char *brand){
      strcpy(_brand, brand);
  }
  ```

  - 那么为什么要这么干呢？

    当类中成员函数庞杂时，看着容易头昏眼花，若只在类中进行声明并加上注释，会方便理解。

- **多文件联合编译时可能出现的错误**

  - 为什么一般不在头文件中定义函数？
  
    若在头文件中定义一个函数，同时多个源文件都包含该头文件，在联合编译时约等于一个源文件都定义了一次这个函数，即会发生重定义错误。
    
  - 类的成员函数也存在这种问题
  
    若在头文件中：类内声明，类外定义。也会发生该错误
  
    解决方法：
  
    1. 类外定义前加上inline，这在头文件中使用是ok的
    2. 直接放类里面定义（实际上跟inline效果一样）
    3. **函数声明放头文件，函数定义放在实现文件中，就算有多个测试文件，也不会出现重定义（最常用）**
  

# 对象的创建

C++ 为类提供了一种<span style=color:red;background:yellow>**特殊的成员函数——构造函数**</span>来完成**真正的初始化**。

- 构造函数的作用：就是用来初始化数据成员的

- 构造函数的形式：

  1. <span style=color:red;background:yellow>**没有返回值，即使是void也不能有；**</span>

  2. <span style=color:red;background:yellow>**函数名与类名相同，再加上函数参数列表。**</span>

构造函数在对象创建时<font color=red>**自动调用**</font>，用以完成**数据成员的初始化，及其他操作**(如为指针成员动态申请内存等)

## 规则

1. 若类中没有显式定义构造函数，编译器会默认自动生成一个无参的构造函数，但不会初始化数据成员

   即如果不定义构造函数，直接Student stu1;然后stu1.print()打印信息，信息未被初始化，都会是不确定的值

2. 显式定义构造函数后，编译器便不会再自动生成默认的构造函数

3. 构造函数也可以接收参数，在对象创建时提供更大的自由度

   ```c++
   //正常做法
   class a{
   public:
       a(int x, int y){
           _x = x;
           _y = y;
       }
       
   private: 
       int _x;
       int _y;
   }
   ```

4. 若要重载(可以做到无参)
   ```c++
   class a{
   public:
       a(){//无参，直接赋值为0
           _x = 0;
           _y = 0;
       }
       
       a(int x, int y = 0){//有参
           _x = x;
           _y = y;
       }
   
   private: 
       int _x;
       int _y;
   }
   //构造一下：
   a a1;//0,0
   a a2(1,2);//1,2
   a a3(10);//10,0
   ```

## 初始化

初始化列表：

```c++
a(int x, int y): _x(x), _y(y){...}
```

补充：**数据成员的初始化取决于声明时的顺序（与声明顺序一致）。**跟初始化列表中的顺序无关。如果初始化列表顺序：a,b。而声明顺序：b,a。流程是先初始化b，再初始化a。

- 构造函数的参数也可以按从右向左规则赋默认值，同样的，若又要在类内声明，类外定义，那么建议只在声明中设置默认值

```c++
//类内
Point(int ix, int iy = 0);//在声明时设置默认参数
//类外
Point::Point(int ix, int iy): _ix(ix), _iy(iy){
	cout << "Point(int,int)" << endl;
}
//调用
Point pt(10);
```

- 不过还是建议在初始化列表中进行初始化

## 对象所占空间大小

对象大小仅是**成员类型所占大小之和**

又因为内存对齐，有时候值有变化，具体看**成员定义的顺序**（顺序到位则可以类似俄罗斯方块那样完美对齐）

如：
    int _num;
    double _price;
int为4字节，double为8字节，但是为了内存对齐，int会单独放在8字节的一行

所以总共占16字节。

除数组外，其他类型的数据成员中，**以较大的数据成员所占空间的倍数去对齐。**

## 指针数据成员

类的数据成员中有指针时，意味着创建该类的对象时要进行指针成员的初始化，需要申请堆空间。

**在初始化列表中申请空间，在函数体中复制内容。**

```c++
Computer(const char * brand, double price)
    : _brand(new char[strlen(brand) + 1]())
	, _price(price)
	{
        strcpy(_brand,brand);
    }
//还得回收空间，有请析构函数↓
```

## 对象的销毁

1. **对象在销毁时，一定会调用析构函数（自动）**

2. 析构函数的作用：<span style=color:red;background:yellow>**清理对象的数据成员申请的资源（堆空间）**</span>；

   不过析构函数并不负责清理数据成员(系统自动完成)

3. 析构函数形式：

   - 仅仅就是~xxx(){}
   - 无返回值，无参数，函数名与类名相同

4. 析构函数只能有一个，不能重载

5. **析构函数默认情况下 ，系统也会自动提供一个**

## 自定义析构函数

ps：析构函数（**des**tructor），与构造函数（**con**structor）对应

**实际上是一个清理“数据成员申请的堆空间”的接口**

使用场景是，数据成员中包含指针时，默认的析构函数不够用了，得自定义该析构函数去堆空间上回收。

如：
```c++
//存在一个char *_brand;
~a(){
    if(_brand){
        delete [] _brand;
        _brand = nullptr;//设为空指针，安全回收
    }
}
```

