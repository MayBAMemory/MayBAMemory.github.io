## explain

>  explain以一种可视化的形式, 帮我们近似展示SQL底层执行的状态/执行计划

### 各个结果字段意义

![image-20240904112606794](/res/img_sql2/explain_select.png)

#### id

> `id标识符`。这是查询中的SELECT的序列号. 我们一般通过id值的大小研究查询中的逻辑顺序.   (但是需要注意的是,它不一定完全代表真实绝对的SQL执行顺序, 是一种**逻辑上的**相对顺序, 在一些特殊操作中未必按照如下说明).
>
> - **id不同时：id值越大，优先级越高，越先被执行**
>
> - **id既有相同又有不同时：不同的id值，id值越大，优先级越高，越先被执行;  相同的id值，按照从上到下的顺序执行**

#### select_type

> `使用的查询类型`。如普通查询、联合查询、子查询等
>
> 常见类型：
>
> | **类型**     | **描述**                                                |
> | ------------ | ------------------------------------------------------- |
> | SIMPLE       | 简单的查询   (查询中不包含子查询或者UNION)              |
> | PRIMARY      | 外层查询 (查询中若包含任何复杂的子部分)                 |
> | SUBQUERY     | 子查询                                                  |
> | DERIVED      | 派生表                                                  |
> | UNION        | 一般属于第二个SELECT,  出现在UNION之后，则被标记为UNION |
> | UNION RESULT | 从UNION表获取结果的SELECT                               |

#### table

> `表名`

partitions

> `分区`。只对设置了分区的表有意义，现在是NULL，暂时忽略。

type

> 显示`MySQL访问表的方式`（比如访问索引，全表扫描等）
>
> > 性能从好到坏：
> >
> > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL 
> >
> > | 常见字段   | 表示含义                                                   |
> > | ---------- | ---------------------------------------------------------- |
> > | **system** | 系统表，或者极少量数据，往往不需要进行磁盘IO               |
> > | **const**  | 常量连接(常数级时间复杂度, 基本上是命中主键)               |
> > | **eq_ref** | 多表关联查询时，主键索引或唯一索引作为关联条件进行等值扫描 |
> > | **re f**   | 非主键或者非唯一索引等值扫描                               |
> > | **range**  | 范围扫描                                                   |
> > | **index**  | 全索引扫描 (比如修改表中数据, 导致所有索引结构变化)        |
> > | **ALL**    | 全表扫描                                                   |
> > | ...        | ...                                                        |

#### possible_keys

> `SQL执行中有可能用到的索引`
>
> - 这列数据是在SQL在优化器初步解析时生成，随着进一步优化，该列索引不一定使用

#### key

> `SQL执行中实际用到的索引`
>
> - 如果为NULL，则没有使用

#### key_len

> ↑上面的`key占用的字节数`
>
> - 索引类型为int时，占用4字节
>
> - long占用8字节
>
> - float占用4字节
>
> - 若key是非主键索引：
>
>   > 比如索引是一个student_name列
>   >
>   > - 类型为varchar(20)
>   > - 使用utf8mb4编码（含义是utf8 most bytes 4，所以最多占用4个字节）
>   > - 允许为null
>   >
>   > 那么**key_len =** **20 * 4 + 1**（NULL）**+ 2** （存储实际数据长度）
>   >
>   > > 展开说说NULL与描述长度
>   > >
>   > > - 数据允许为null，则需额外占1个字节，所以索引字段最好不要允许为null
>   > > - 在InnoDB存储引擎中，索引中的**变长字段**通常使用**2个字节**来存储长度前缀。比如在数据为**武松**时（在utf8mb4中一个汉字占3字节，所以武松需要占6字节）而那2字节就是用来存储`6`这个数字。2个字节可表示的最大长度为65535（2^16 - 1）



